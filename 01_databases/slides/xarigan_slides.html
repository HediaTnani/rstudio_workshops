<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>Working with Databases in R</title>
    <meta charset="utf-8" />
    <meta name="author" content="Hadrien Dykiel &amp; Alex Gold (Credit: Edgar Ruiz, James Blair)" />
    <meta name="date" content="2020-02-26" />
    <link href="xarigan_slides_files/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="xarigan_slides_files/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Working with Databases in R
### Hadrien Dykiel &amp; Alex Gold (Credit: Edgar Ruiz, James Blair)
### 2020-02-26

---





# Schedule
1. Strategies for Writing Queries
2. Mechanics of Querying Databases
- Connecting
- Writing + Sending Queries
3. Deploying to RStudio Connect w/ Live Connections

---

# I. 3 Strategies for Efficient Queries
1. Sample and Model
2. Chunk and Pull
3. Push Compute to Data
--


(Not exclusive!)
---

## Strategy 1: Sample and Model
.center[
![Sample and Model](images/sample_and_model.png)
]
--

üòÉ Use favorite R modeling package (`caret/parsnip/rsample`).

üòÉ Really good for iterating/prototyping.

‚òπÔ∏è Requires care for sampling and scaling. 

‚òπÔ∏è Not good for BI tasks.


---

## 2. Chunk and Pull
.center[
![Chunk and Pull](images/chunk_and_pull.png)
]

--
üòÉ Great when discrete chunks exist.

üòÉ Facilitates parallelization.

‚òπÔ∏è Can‚Äôt have interactions between chunks.

‚òπÔ∏è Eventually pull in all data.

---

## 3. Push Compute to Data
.center[
![Sample and Model](images/push_compute.png)
]
--

üòÉ Take advantage of database strengths.

üòÉ Get whole dataset, but move less data.

‚òπÔ∏è Operations might not be permitted in database.

‚òπÔ∏è Maybe your database is slow?

---

# II. The Mechanics

db.rstudio.com

### R Packages
- `DBI`: "front-end" for database connections w/ back-end options
- `RPostgres`
- `RMariaDB`
- `RSQLite`
- `bigrquery`
- `odbc` &lt;- generic option, works with Open Database Connectivity (ODBC) system (Pro Drivers)


Process: 

`Write Code` -&gt; `Translate code` -&gt; `Package sends to database` -&gt; `Response`

---

## Connection Methods

https://db.rstudio.com/best-practices/managing-credentials/

- Connections Pane
- Code

--

### Using a DSN

```r
con &lt;- dbConnect(odbc::odbc(), "Postgres Prod", timeout = 10)
dbDisconnect(con)
```

*Examine `/etc/odbc.ini` and `/etc/odbcinst.ini`*

--

### Prompting for Passwords
username `rstudio_prod`, pwd `prod_user` (weird order of dialogs...)

```r
con &lt;- dbConnect(
  odbc::odbc(),
  Driver = "PostgreSQL",
  Server = "localhost",
  UID    = rstudioapi::askForPassword("Database user"),
  PWD    = rstudioapi::askForPassword("Database password"),
  Port = 5432,
  Database = "postgres"
)
dbDisconnect(con)
```

--

### Config Package

```r
cfg &lt;- config::get(file = here::here("01_databases/slides/config.yml"))
```

```
## Warning in readLines(con): incomplete final line found on '/home/
## john_deere_user/class-repo/01_databases/slides/config.yml'
```

```r
con &lt;- dbConnect(odbc::odbc(),
                 Driver = cfg$driver,
                 Server = cfg$server,
                 UID    = cfg$uid,
                 PWD    = cfg$pwd,
                 Port   = cfg$port,
                 Database = cfg$database
)
```

--

### Environment Variables

`Sys.setenv(var = "val")`

`~/.Rprofile`

Project `.Rprofile`

---

**Exercise**

_Connect to a database and Explore_

1. Click on the `Connections` tab

2. Click on the `New Connection` button

3. Select `Postgres Prod`

4. Click OK

5. Explore the `retail` schema in the IDE.

6. Click the disconnect button (red x).

7. Re-connect using code generated by `Connections` tab.

---

## Interacting with Databases

- SQL code chunks (or scripts)
- `dbGetQuery`
- dplyr

---
### SQL Code Chunks
Include a SQL code chunk in an RMarkdown doc.

https://bookdown.org/yihui/rmarkdown/language-engines.html#sql

`{sql, connection = con}`


```sql
/* SQL Chunk */
SELECT * FROM retail.orders LIMIT 10;
```


&lt;div class="knitsql-table"&gt;


Table: Displaying records 1 - 10

order_id    customer_id   step_id
---------  ------------  --------
1001                 22         1
1002                  6         1
1003                 80         1
1004                 55         1
1005                 73         1
1006                 70         1
1007                 55         1
1008                 40         1
1009                 78         1
1010                 35         1

&lt;/div&gt;

---
Add an `output.var` argument to read into R

`{sql, connection = con, output.var = "dat"}`


```sql
/* SQL Chunk */
SELECT * FROM retail.orders LIMIT 10;
```


```r
# r chunk
dat
```

```
##    order_id customer_id step_id
## 1      1001          22       1
## 2      1002           6       1
## 3      1003          80       1
## 4      1004          55       1
## 5      1005          73       1
## 6      1006          70       1
## 7      1007          55       1
## 8      1008          40       1
## 9      1009          78       1
## 10     1010          35       1
```

If same for all SQL chunks: `knitr::opts_chunk$set(connection = "con")`

Can also do entire scripts.
---

### `dbGetQuery`

Get a list of tables

```r
library(DBI)
DBI::dbListTables(con)
```

```
## [1] "customer"    "date"        "line_item"   "orders"      "product"    
## [6] "v_lineitems" "v_orders"
```

### Send a query

```r
dat &lt;- DBI::dbGetQuery(con, "SELECT * FROM retail.date LIMIT 10;")
dat
```

```
##    step_id       date date_year date_month date_month_name  date_day
## 1        1 2016-01-01      2016          1             Jan    Friday
## 2        2 2016-01-02      2016          1             Jan  Saturday
## 3        3 2016-01-03      2016          1             Jan    Sunday
## 4        4 2016-01-04      2016          1             Jan    Monday
## 5        5 2016-01-05      2016          1             Jan   Tuesday
## 6        6 2016-01-06      2016          1             Jan Wednesday
## 7        7 2016-01-07      2016          1             Jan  Thursday
## 8        8 2016-01-08      2016          1             Jan    Friday
## 9        9 2016-01-09      2016          1             Jan  Saturday
## 10      10 2016-01-10      2016          1             Jan    Sunday
```


## dplyr + Databases = dbplyr

### Connect to a Table

```r
library(dplyr)
library(dbplyr)
```

```
## 
## Attaching package: 'dbplyr'
```

```
## The following objects are masked from 'package:dplyr':
## 
##     ident, sql
```

```r
library(DBI)
```


```r
cust &lt;- tbl(con, in_schema("retail", "customer"))

cust
```

```
## # Source:   table&lt;retail.customer&gt; [?? x 6]
## # Database: postgres [rstudio_prod@localhost:/postgres]
##    customer_id customer_name customer_phone customer_cc customer_lon
##          &lt;int&gt; &lt;chr&gt;         &lt;chr&gt;          &lt;chr&gt;              &lt;dbl&gt;
##  1           1 Marilou Donn‚Ä¶ 046-995-9387x‚Ä¶ 4054106117‚Ä¶        -122.
##  2           2 Aubrey Gulgo‚Ä¶ (020)136-2064  6759766520‚Ä¶        -122.
##  3           3 Arlis Koss    145.574.8189   8699968904‚Ä¶        -122.
##  4           4 Duwayne Walsh 737-897-1968x‚Ä¶ 4091991124‚Ä¶        -122.
##  5           5 Nehemiah Doy‚Ä¶ (035)642-3662‚Ä¶ 3709535249‚Ä¶        -122.
##  6           6 Meggan Bruen  326-151-4331   4964180480‚Ä¶        -122.
##  7           7 Tracie Swift‚Ä¶ 776.442.3270x‚Ä¶ 4354911637‚Ä¶        -122.
##  8           8 Karrie Donne‚Ä¶ 883.024.5322x‚Ä¶ 4232403376‚Ä¶        -122.
##  9           9 Kip Eichmann  (619)169-8761‚Ä¶ 5177848238‚Ä¶        -122.
## 10          10 Ms. Ciarra B‚Ä¶ 964-240-3124   4893126879‚Ä¶        -122.
## # ‚Ä¶ with more rows, and 1 more variable: customer_lat &lt;dbl&gt;
```

*Question:* What is cust? What will I get from `names(cust)`?

--


```r
names(df)
```

```
## NULL
```

ü§Ø
---

### Under the hood

SQL statement that actually runs when we ran `cust` as a command

```r
cust %&gt;%
  dplyr::show_query()
```

```
## &lt;SQL&gt;
## SELECT *
## FROM retail.customer
```

--

Use normal dplyr verbs to build tables

```r
q &lt;- cust %&gt;%
  filter(customer_lon &lt; -122.4463) %&gt;%
  select(customer_name, customer_phone)

q
```

```
## # Source:   lazy query [?? x 2]
## # Database: postgres [rstudio_prod@localhost:/postgres]
##    customer_name             customer_phone     
##    &lt;chr&gt;                     &lt;chr&gt;              
##  1 Marilou Donnelly DVM      046-995-9387x9542  
##  2 Aubrey Gulgowski III      (020)136-2064      
##  3 Nehemiah Doyle-Schimmel   (035)642-3662x356  
##  4 Kip Eichmann              (619)169-8761x98047
##  5 Ms. Ciarra Borer          964-240-3124       
##  6 Mordechai Schultz         (613)785-8789      
##  7 Elayne Swaniawski-Hilpert 1-634-989-0156x458 
##  8 Kris Bednar               301.244.1689x3452  
##  9 Miss Azzie Jaskolski      (634)363-1830x7533 
## 10 Dr. Birdie Kessler        684.226.0455       
## # ‚Ä¶ with more rows
```

```r
show_query(q)
```

```
## &lt;SQL&gt;
## SELECT "customer_name", "customer_phone"
## FROM retail.customer
## WHERE ("customer_lon" &lt; -122.4463)
```

### Un-Translated Functions

What happens if I put in an R command w/ no SQL component?

```r
cust %&gt;%
  mutate(today = Sys.time()) %&gt;%
  show_query()
```

```
## &lt;SQL&gt;
## SELECT "customer_id", "customer_name", "customer_phone", "customer_cc", "customer_lon", "customer_lat", Sys.time() AS "today"
## FROM retail.customer
```
--

Use PostgreSQL's native commands, in this case `now()`

```r
q &lt;- cust %&gt;%
  transmute(today = now())

q
```

```
## # Source:   lazy query [?? x 1]
## # Database: postgres [rstudio_prod@localhost:/postgres]
##    today              
##    &lt;dttm&gt;             
##  1 2020-02-19 22:26:32
##  2 2020-02-19 22:26:32
##  3 2020-02-19 22:26:32
##  4 2020-02-19 22:26:32
##  5 2020-02-19 22:26:32
##  6 2020-02-19 22:26:32
##  7 2020-02-19 22:26:32
##  8 2020-02-19 22:26:32
##  9 2020-02-19 22:26:32
## 10 2020-02-19 22:26:32
## # ‚Ä¶ with more rows
```

```r
q  %&gt;%
  show_query()
```

```
## &lt;SQL&gt;
## SELECT CURRENT_TIMESTAMP AS "today"
## FROM retail.customer
```

--



```r
cust %&gt;%
  mutate(today = now()) %&gt;%
  select(today) %&gt;%
  head()
```

```
## # Source:   lazy query [?? x 1]
## # Database: postgres [rstudio_prod@localhost:/postgres]
##   today              
##   &lt;dttm&gt;             
## 1 2020-02-19 22:26:32
## 2 2020-02-19 22:26:32
## 3 2020-02-19 22:26:32
## 4 2020-02-19 22:26:32
## 5 2020-02-19 22:26:32
## 6 2020-02-19 22:26:32
```

###  Evaluate Before Sending

Preview how `Sys.time()` is translated

```r
cust %&gt;%
  mutate(today = Sys.time()) %&gt;%
  show_query()
```

```
## &lt;SQL&gt;
## SELECT "customer_id", "customer_name", "customer_phone", "customer_cc", "customer_lon", "customer_lat", Sys.time() AS "today"
## FROM retail.customer
```

But when prefixed w/ bang-bang (`!!`)

```r
cust %&gt;%
  mutate(today = !!Sys.time()) %&gt;%
  show_query()
```

```
## &lt;SQL&gt;
## SELECT "customer_id", "customer_name", "customer_phone", "customer_cc", "customer_lon", "customer_lat", '2020-02-19T22:26:32Z' AS "today"
## FROM retail.customer
```

### Basic aggregation

How many records are in the **product** table?

--


```r
prods &lt;- tbl(con, in_schema("retail", "product"))  

prods %&gt;%
  tally()
```

```
## # Source:   lazy query [?? x 1]
## # Database: postgres [rstudio_prod@localhost:/postgres]
##   n      
##   &lt;int64&gt;
## 1 30
```

---
### Controlling Returns
What is this object?

```r
n_prods &lt;- prods %&gt;% tally()
```

--


```r
names(n_prods)
```

```
## [1] "src" "ops"
```

How do I get a real R object?

--


```r
n_prods &lt;- collect(n_prods)
n_prods
```

```
## # A tibble: 1 x 1
##   n      
##   &lt;int64&gt;
## 1 30
```

```r
names(n_prods)
```

```
## [1] "n"
```

---

### Basic aggregation 2
What is the average customer longitude?  Average length of customer names?
--


```r
cust %&gt;%
  summarise(
    avg_cust_lon = mean(customer_lon, na.rm = TRUE),
    avg_cust_name = mean(str_length(customer_name), na.rm = TRUE)
  )
```

```
## # Source:   lazy query [?? x 2]
## # Database: postgres [rstudio_prod@localhost:/postgres]
##   avg_cust_lon avg_cust_name
##          &lt;dbl&gt;         &lt;dbl&gt;
## 1        -122.          16.3
```

How many records are in the **orders** table?


What's the most recent date in the **date** table?


What is the SQL statement sent to find the date in the table above?



# III. Deployment to RStudio Connect

Register RStudio Connect Server

- Deploy to: `[http://URL...amazonaws.com]/rsconnect`
- Username: `john_deere_user`
- Password: `john_deere_pass`
- Email: whatever you want (fake ok)

---

For the shiny app, will need to add environment variables. 


---
# Appendix
- These slides were created with `rmarkdown` and `xaringan`. To learn more about the `xaringan` package, check out Alision's slides from her rstudio::conf 2019 workshop https://arm.rbind.io/slides/xaringan.html
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create();
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
